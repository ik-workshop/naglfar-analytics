flowchart TD
    Start([Incoming HTTP Request]) --> Metrics[Prometheus HTTP Metrics Middleware]
    Metrics --> AuthMW[Authentication Middleware]

    AuthMW --> InfraCheck{Is Infrastructure<br/>Endpoint?}

    InfraCheck -->|"/healthz<br/>/readyz<br/>/metrics<br/>/swagger/*"| LocalHandler[Local Handler:<br/>Health Check]

    InfraCheck -->|No - Other Path| AuthCheck{Has<br/>AUTH-TOKEN<br/>Header?}

    AuthCheck -->|Yes| YARPProxy[YARP Reverse Proxy]
    YARPProxy --> Backend[Backend Service<br/>protected-service-eu:8000]
    Backend --> Response1[HTTP Response]

    AuthCheck -->|No| ExtractData[Extract Data:<br/>- store_id from path<br/>- CLIENT_IP from header]

    ExtractData --> GenerateEToken[Generate New E-TOKEN<br/>Base64 JSON:<br/>{expiry_date, store_id}]

    GenerateEToken --> PublishRedis[Publish to Redis<br/>Channel: naglfar-events<br/>{client_ip, store_id, action: e-token}]

    PublishRedis --> SetHeader[Set E-TOKEN Header]
    SetHeader --> Redirect[302 Redirect to Auth Service]

    Redirect --> RedirectURL[Location: auth-service?<br/>return_url=original_path<br/>&e_token=base64_json]
    RedirectURL --> AuthService[Auth Service<br/>localhost:8090/auth]

    AuthService --> UserAuth[User Authenticates]
    UserAuth --> SetAuthHeader[Auth Service Sets<br/>AUTH-TOKEN Header]
    SetAuthHeader --> RedirectBack[Redirect Back to<br/>Original return_url]
    RedirectBack --> Start

    LocalHandler --> Response2[HTTP Response]

    style InfraCheck fill:#e1f5ff
    style AuthCheck fill:#fff4e1
    style YARPProxy fill:#e8f5e9
    style Redirect fill:#ffebee
    style AuthMW fill:#f3e5f5
    style PublishRedis fill:#fce4ec
    style ExtractData fill:#fff9c4
