# Naglfar Analytics - Graph Database Model Specification
# Version: 2.0 (Simplified Event-Centric Model)
# Based on: specs/graph-model.md
# Date: 2025-12-29

version: "2.0"
description: "Event-centric graph model for abuse detection. Entities are identity nodes, Events contain all data."

design_philosophy:
  principle: "Pure event-centric model. Entities are identity containers. Events contain all data. Abuse detection happens through Event queries."

  entity_role: "Minimal nodes representing identity (IP, Session, User, Store)"
  entity_properties: "Only ID and timestamps - no business data, no behavioral data"

  event_role: "Rich nodes containing all request/event data including context"
  event_properties: "All business data, user context, request details, temporal information"

  relationship_strategy: "All relationships go Event → Entity (never Entity → Entity)"
  relationship_role: "Connect Events to Entities for querying and grouping"

  abuse_detection: "Query Event patterns and relationships, not entity properties"
  temporal_queries: "All time-based analysis uses Event timestamps and relationships"

design_decisions:
  no_direct_entity_relationships:
    decision: "No User → Session, User → Store, or IPAddress → Session relationships"
    reason: "Direct relationships lose temporal context - we need to know WHEN relationships occurred"
    example: "To detect 'IP used by multiple users in last hour' we need Event timestamps, not static relationships"

  no_entity_business_data:
    decision: "Entities don't store email, user_agent, device_type, or other business data"
    reason: "Events are the source of truth. Entity data can change over time and should be queried from Events"
    example: "User email stored in Events, not User node. Query most recent Event for current email"

  event_denormalization:
    decision: "Events denormalize identity fields (client_ip, user_id, session_id, store_id)"
    reason: "Fast queries without joins. Events are immutable so denormalization is safe"
    example: "Event contains client_ip field AND relationship to IPAddress node"

  entity_lifecycle:
    decision: "Entities are created on first Event, updated (timestamps) on subsequent Events"
    reason: "Entities represent 'existence' while Events represent 'activity'"
    example: "Session created when first Event with session_id arrives, last_activity updated on each Event"

# ==============================================================================
# ENTITY DEFINITIONS
# ==============================================================================

entities:
  # IP Address - Identity node for grouping events by IP
  IPAddress:
    label: "IPAddress"
    description: "Represents a unique client IP address"
    properties:
      address:
        type: "string"
        required: true
        indexed: true
        unique: true
        description: "IP address (IPv4 or IPv6)"
      first_seen:
        type: "datetime"
        required: true
        description: "First time this IP was observed"
      last_seen:
        type: "datetime"
        required: true
        description: "Most recent activity from this IP"

  # Session - Identity node for grouping events by session
  Session:
    label: "Session"
    description: "Represents a user session (UUID v7)"
    properties:
      session_id:
        type: "string"
        required: true
        indexed: true
        unique: true
        description: "Session identifier (UUID v7)"
      created_at:
        type: "datetime"
        required: true
        description: "Session creation timestamp"
      last_activity:
        type: "datetime"
        required: true
        description: "Most recent activity in this session"

  # User - Identity node for grouping events by user
  User:
    label: "User"
    description: "Represents an authenticated user account"
    properties:
      user_id:
        type: "integer"
        required: true
        indexed: true
        unique: true
        description: "User account ID"
      created_at:
        type: "datetime"
        required: true
        description: "First seen timestamp"

  # Store - Identity node for grouping events by store
  Store:
    label: "Store"
    description: "Represents a store/tenant in the system"
    properties:
      store_id:
        type: "string"
        required: true
        indexed: true
        unique: true
        description: "Store identifier (e.g., 'store-1')"
      created_at:
        type: "datetime"
        required: true
        description: "First seen timestamp"

  # Event - Primary data node containing all event information
  Event:
    label: "Event"
    description: "Represents a single event occurrence. This is the primary data node."
    properties:
      event_id:
        type: "string"
        required: true
        indexed: true
        unique: true
        description: "Unique event identifier (UUID)"
      action:
        type: "string"
        required: true
        indexed: true
        description: "Event action (e.g., 'auth_token_validated', 'e_token_created', 'view_books')"
      status:
        type: "string"
        required: false
        indexed: true
        description: "Event status ('pass', 'fail') - for auth events only"
      timestamp:
        type: "datetime"
        required: true
        indexed: true
        description: "Event occurrence timestamp (ISO 8601)"
      client_ip:
        type: "string"
        required: true
        indexed: true
        description: "Client IP address (denormalized for quick access)"
      user_agent:
        type: "string"
        required: false
        description: "User agent string"
      device_type:
        type: "string"
        required: false
        indexed: true
        description: "Device type ('mobile' or 'web')"
      path:
        type: "string"
        required: true
        indexed: true
        description: "Request path (without query string)"
      query:
        type: "string"
        required: false
        description: "Query string"
      session_id:
        type: "string"
        required: false
        indexed: true
        description: "Session identifier (if available)"
      user_id:
        type: "integer"
        required: false
        indexed: true
        description: "User ID (if authenticated)"
      store_id:
        type: "string"
        required: false
        indexed: true
        description: "Store identifier (if available)"
      auth_token_id:
        type: "string"
        required: false
        indexed: true
        description: "Auth token identifier (if available)"
      data:
        type: "json"
        required: false
        description: "Event-specific data payload (JSON)"
      archived:
        type: "boolean"
        required: true
        indexed: true
        default: false
        description: "Whether event has been archived (excluded from active queries)"

# ==============================================================================
# RELATIONSHIP DEFINITIONS
# ==============================================================================

relationships:
  # Event → IPAddress
  - type: "ORIGINATED_FROM"
    description: "Event originated from this IP address"
    from: "Event"
    to: "IPAddress"
    cardinality: "many-to-one"
    required: true
    properties:
      timestamp:
        type: "datetime"
        required: true
        description: "When this event occurred"
    notes: "Always created for every event"

  # Event → Session
  - type: "IN_SESSION"
    description: "Event occurred in this session"
    from: "Event"
    to: "Session"
    cardinality: "many-to-one"
    required: false
    properties:
      timestamp:
        type: "datetime"
        required: true
        description: "When this event occurred"
    notes: "Only created if event has session_id"

  # Event → User
  - type: "PERFORMED_BY"
    description: "Event performed by this user"
    from: "Event"
    to: "User"
    cardinality: "many-to-one"
    required: false
    properties:
      timestamp:
        type: "datetime"
        required: true
        description: "When this event occurred"
    notes: "Only created if event has user_id (authenticated events)"

  # Event → Store
  - type: "TARGETED_STORE"
    description: "Event targeted this store"
    from: "Event"
    to: "Store"
    cardinality: "many-to-one"
    required: false
    properties:
      timestamp:
        type: "datetime"
        required: true
        description: "When this event occurred"
      path:
        type: "string"
        required: true
        description: "Request path (denormalized for quick access)"
      query:
        type: "string"
        required: false
        description: "Query string (denormalized)"
    notes: "Only created if event has store_id"

  # Event → Event (Temporal)
  - type: "NEXT_EVENT"
    description: "Sequential event in same session"
    from: "Event"
    to: "Event"
    cardinality: "one-to-one"
    required: false
    properties:
      time_delta_ms:
        type: "integer"
        required: true
        description: "Milliseconds between events"
    notes: "Only created between consecutive events in same session"

# ==============================================================================
# INDEXES AND CONSTRAINTS
# ==============================================================================

indexes:
  # Unique Constraints
  - entity: "IPAddress"
    property: "address"
    type: "unique"
    description: "Unique constraint on IP address"

  - entity: "Session"
    property: "session_id"
    type: "unique"
    description: "Unique constraint on session ID"

  - entity: "User"
    property: "user_id"
    type: "unique"
    description: "Unique constraint on user ID"

  - entity: "Store"
    property: "store_id"
    type: "unique"
    description: "Unique constraint on store ID"

  - entity: "Event"
    property: "event_id"
    type: "unique"
    description: "Unique constraint on event ID"

  # Event Performance Indexes
  - entity: "Event"
    property: "timestamp"
    type: "index"
    description: "Critical for time-window abuse detection queries"

  - entity: "Event"
    property: "action"
    type: "index"
    description: "Filter by event type"

  - entity: "Event"
    property: "status"
    type: "index"
    description: "Filter by pass/fail"

  - entity: "Event"
    property: "path"
    type: "index"
    description: "Identify targeted endpoints"

  - entity: "Event"
    property: "client_ip"
    type: "index"
    description: "Quick IP lookup in events"

  - entity: "Event"
    property: "device_type"
    type: "index"
    description: "Filter by mobile/web"

  - entity: "Event"
    property: "session_id"
    type: "index"
    description: "Quick session lookup"

  - entity: "Event"
    property: "user_id"
    type: "index"
    description: "Quick user lookup"

  - entity: "Event"
    property: "store_id"
    type: "index"
    description: "Quick store lookup"

  - entity: "Event"
    property: "auth_token_id"
    type: "index"
    description: "Token abuse detection"

  # Composite Index
  - entity: "Event"
    properties:
      - "action"
      - "status"
      - "timestamp"
    type: "composite"
    description: "Common abuse detection queries (e.g., failed auth in time window)"

# ==============================================================================
# EVENT SOURCES
# ==============================================================================

event_sources:
  layer_3_4:
    description: "naglfar-validation service (auth layer)"
    events:
      - action: "auth_token_validated"
        status: "pass or fail"
        fields: ["client_ip", "user_agent", "device_type", "path", "query", "store_id", "session_id", "user_id", "auth_token_id"]
      - action: "e_token_created"
        fields: ["client_ip", "user_agent", "device_type", "path", "query", "store_id"]

  layer_5:
    description: "Backend services (book-store, etc.) - analytics only"
    events:
      - action: "view_books, add_to_cart, checkout, etc."
        fields: ["session_id", "user_id", "store_id", "client_ip", "device_type", "auth_token_id", "data"]

# ==============================================================================
# ABUSE DETECTION QUERIES
# ==============================================================================

abuse_patterns:
  brute_force:
    description: "Detect IPs with multiple failed auth attempts"
    query: |
      MATCH (e:Event)-[:ORIGINATED_FROM]->(ip:IPAddress)
      WHERE e.action = 'auth_token_validated'
        AND e.status = 'fail'
        AND e.timestamp > datetime() - duration('PT5M')
      WITH ip.address as ip_address, count(e) as failed_count
      WHERE failed_count >= 10
      RETURN ip_address, failed_count
      ORDER BY failed_count DESC
    threshold: 10
    window: "5 minutes"

  ddos:
    description: "Detect IPs making excessive requests"
    query: |
      MATCH (e:Event)-[:ORIGINATED_FROM]->(ip:IPAddress)
      WHERE e.timestamp > datetime() - duration('PT1M')
      WITH ip.address as ip_address, count(e) as request_count
      WHERE request_count > 100
      RETURN ip_address, request_count
      ORDER BY request_count DESC
    threshold: 100
    window: "1 minute"

  session_sharing:
    description: "Detect sessions used by multiple user accounts"
    query: |
      MATCH (e:Event)-[:IN_SESSION]->(s:Session)
      WHERE e.user_id IS NOT NULL
      WITH s.session_id as session_id, collect(DISTINCT e.user_id) as user_ids
      WHERE size(user_ids) > 1
      RETURN session_id, user_ids, size(user_ids) as user_count
      ORDER BY user_count DESC
    threshold: 1

  ip_behavior:
    description: "Detect IPs used by multiple user accounts"
    query: |
      MATCH (e:Event)-[:ORIGINATED_FROM]->(ip:IPAddress)
      WHERE e.user_id IS NOT NULL
        AND e.timestamp > datetime() - duration('PT1H')
      WITH ip.address as ip_address, collect(DISTINCT e.user_id) as user_ids
      WHERE size(user_ids) > 5
      RETURN ip_address, user_ids, size(user_ids) as user_count
      ORDER BY user_count DESC
    threshold: 5
    window: "1 hour"

  store_attacks:
    description: "Identify most attacked stores and endpoints"
    query: |
      MATCH (e:Event)-[:TARGETED_STORE]->(store:Store)
      WHERE e.action = 'auth_token_validated'
        AND e.status = 'fail'
        AND e.timestamp > datetime() - duration('PT1H')
      WITH store.store_id as store_id, count(e) as failed_attempts
      RETURN store_id, failed_attempts
      ORDER BY failed_attempts DESC
      LIMIT 10
    window: "1 hour"

  token_abuse:
    description: "Detect auth tokens used by different users or stores"
    query: |
      MATCH (e:Event)
      WHERE e.auth_token_id IS NOT NULL
        AND e.user_id IS NOT NULL
        AND e.timestamp > datetime() - duration('PT1H')
      WITH e.auth_token_id as token_id, collect(DISTINCT e.user_id) as user_ids
      WHERE size(user_ids) > 1
      RETURN token_id, user_ids, size(user_ids) as user_count
      ORDER BY user_count DESC
    threshold: 1
    window: "1 hour"

  flow_anomaly:
    description: "Detect IPs that validate tokens without requesting e_token"
    query: |
      MATCH (e_auth:Event)-[:ORIGINATED_FROM]->(ip:IPAddress)
      WHERE e_auth.action = 'auth_token_validated'
        AND e_auth.timestamp > datetime() - duration('PT24H')
      WITH ip, collect(e_auth) as auth_events
      MATCH (e_token:Event)-[:ORIGINATED_FROM]->(ip)
      WHERE e_token.action = 'e_token_created'
        AND e_token.timestamp > datetime() - duration('PT24H')
      WITH ip, auth_events, collect(e_token) as token_events
      WHERE size(auth_events) > 0 AND size(token_events) = 0
      RETURN ip.address, size(auth_events) as auth_count
      ORDER BY auth_count DESC
    window: "24 hours"

  endpoint_targeting:
    description: "Identify most targeted endpoints"
    query: |
      MATCH (e:Event)
      WHERE e.action = 'auth_token_validated'
        AND e.status = 'fail'
        AND e.timestamp > datetime() - duration('PT1H')
      WITH e.path as path, count(e) as failed_count
      RETURN path, failed_count
      ORDER BY failed_count DESC
      LIMIT 20
    window: "1 hour"

  device_anomaly:
    description: "Detect unusual device type patterns (same session switching devices)"
    query: |
      MATCH (e:Event)-[:IN_SESSION]->(s:Session)
      WHERE e.device_type IS NOT NULL
        AND e.timestamp > datetime() - duration('PT1H')
      WITH s.session_id as session_id, collect(DISTINCT e.device_type) as device_types
      WHERE size(device_types) > 1
      RETURN session_id, device_types
      ORDER BY size(device_types) DESC
    threshold: 1
    window: "1 hour"

  mobile_vs_web_attacks:
    description: "Compare attack patterns by device type"
    query: |
      MATCH (e:Event)
      WHERE e.action = 'auth_token_validated'
        AND e.status = 'fail'
        AND e.timestamp > datetime() - duration('PT24H')
      WITH e.device_type as device_type, count(e) as failed_count
      RETURN device_type, failed_count
      ORDER BY failed_count DESC
    window: "24 hours"

# ==============================================================================
# DATA FLOW
# ==============================================================================

data_flow:
  event_processing:
    - step: "Event arrives from Redis"
    - step: "Extract all fields from event JSON"
    - step: "Create Event node with all properties"
    - step: "MERGE entities (IPAddress, Session, User, Store)"
    - step: "Create relationships (Event → entities)"
    - step: "Create temporal link (Event → previous Event in session)"

  batch_processing:
    description: "Process events in batches for performance"
    batch_size: 50
    transaction: "Single transaction per batch"
    entity_handling: "MERGE (idempotent)"
    event_handling: "CREATE (always new)"

# ==============================================================================
# EXAMPLE: WHY PURE EVENT-CENTRIC MODEL
# ==============================================================================

example_queries:
  why_no_direct_relationships:
    description: "Shows why we don't create User → Session or IPAddress → Session relationships"

    wrong_approach_with_direct_relationships: |
      # ❌ WRONG: With direct User → Session relationships
      MATCH (u:User)-[:HAS_SESSION]->(s:Session)
      WHERE u.user_id = 1001
      RETURN s.session_id

      # Problem: Lost temporal context
      # - Can't answer "When did user use this session?"
      # - Can't answer "Which events happened in this session?"
      # - Can't detect session sharing in specific time window

    correct_approach_event_centric: |
      # ✅ CORRECT: Query through Events
      MATCH (e:Event)-[:PERFORMED_BY]->(u:User {user_id: 1001})
      MATCH (e)-[:IN_SESSION]->(s:Session)
      WHERE e.timestamp > datetime() - duration('PT24H')
      RETURN DISTINCT s.session_id, min(e.timestamp) as first_use, max(e.timestamp) as last_use

      # Benefits:
      # - Temporal context preserved (when user used session)
      # - Can filter by time window
      # - Can see what events happened
      # - Can detect abuse patterns

  session_sharing_detection: |
    # Detect sessions used by multiple users (temporal context needed)
    MATCH (e:Event)-[:IN_SESSION]->(s:Session)
    WHERE e.user_id IS NOT NULL
      AND e.timestamp > datetime() - duration('PT1H')  # Last hour only
    WITH s.session_id as session_id,
         collect(DISTINCT e.user_id) as user_ids,
         min(e.timestamp) as first_event,
         max(e.timestamp) as last_event
    WHERE size(user_ids) > 1
    RETURN session_id, user_ids, first_event, last_event

    # This query would be IMPOSSIBLE with static User → Session relationships
    # because we need to know WHEN the sharing occurred

  ip_behavior_temporal: |
    # Detect IPs used by multiple users in specific time window
    MATCH (e:Event)-[:ORIGINATED_FROM]->(ip:IPAddress)
    WHERE e.user_id IS NOT NULL
      AND e.timestamp > datetime() - duration('PT1H')  # Critical: time window
    WITH ip.address as ip_address,
         collect(DISTINCT e.user_id) as user_ids,
         count(e) as event_count
    WHERE size(user_ids) > 5
    RETURN ip_address, user_ids, event_count

    # Static IPAddress → User relationships would show ALL users EVER
    # Event-centric approach shows users in SPECIFIC TIME WINDOW

  user_email_lookup: |
    # Get user's current email (most recent Event)
    MATCH (e:Event)-[:PERFORMED_BY]->(u:User {user_id: 1001})
    WHERE e.user_email IS NOT NULL
    RETURN e.user_email as current_email
    ORDER BY e.timestamp DESC
    LIMIT 1

    # Email changes over time - stored in Events, not User node
    # User node is just identity container (user_id)

# ==============================================================================
# NOTES
# ==============================================================================

notes:
  - "This is version 2.0 - PURE event-centric model"
  - "Version 1.0 (archived) had entity counters and abuse state - now removed"
  - "All abuse detection happens through Event queries"
  - "Entities are minimal identity nodes only (ID + timestamps)"
  - "NO direct entity-to-entity relationships (User → Session, User → Store, etc.)"
  - "ALL relationships go through Events to preserve temporal context"
  - "Business data (email, user_agent, device_type) stored in Events, NOT entities"
  - "Events denormalize identity fields for fast queries"
  - "Event nodes can be pruned/archived over time"
  - "Single source of truth: Event nodes"
  - "Design decision: Keep pure event-centric to maintain temporal context for abuse detection"
